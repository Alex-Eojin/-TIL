# 스코프

- 출처 [모던 자바스크립트 Deep Dive](http://www.yes24.com/Product/Goods/92742567?OzSrank=1)을 보고 정리한 내용입니다.

## 1. 스코프란?

<br>

**스코프(scope, 유효범위)[용어]** 는 모든

프로그래밍의 가장 기본적이며 중요한 개념이다.

```jsx
function add(x, y) {
  // 매개변수는 함수 몸체 내부에서만 참조할 수 있다.
  // 즉, 매개변수의 스코프(유효범위)는 함수 몸체 내부다.
  console.log(x, y); // 2 5
  return x + y;
}

add(2, 5);

// 매개변수는 함수 몸체 내부에서만 참조할 수 있다.
console.log(x, y); // ReferenceError: x is not defined
```

<br>

**예제풀이)**

매개변수는 참조할 수 있는 유효범위,

**즉 매개변수의 스코프가 함수 몸체 내부로**

**한정되어 있다.**

<br>

```jsx
var var1 = 1; // 코드의 가장 바깥 영역에서 선언한 변수

if (true) {
  var var2 = 2; // 코드 블록 내에서 선언한 변수
  if (true) {
    var var3 = 3; // 중첩된 코드 블록 내에서 선언한 변수
  }
}

function foo() {
  var var4 = 4; // 함수 내에서 선언한 변수

  function bar() {
    var var5 = 5; // 중첩된 함수 내에서 선언한 변수
  }
}

console.log(var1); // 1
console.log(var2); // 2
console.log(var3); // 3
console.log(var4); // ReferenceError: var4 is not defined
console.log(var5); // ReferenceError: var5 is not defined
```

<br>

**모든 식별자**(변수 이름, 함수 이름, 클래스 이름 등)

**자신의 선언된 위치에 따라 스코프가 결정된다.**

<br>

**즉!**

**스코프는 식별자가 유효한 범위를 말한다.**

<br>

```jsx
var x = 'global';

function foo() {
  var x = 'local';
  console.log(x); // ①
}

foo();

console.log(x); // ②
```

<br>

**예제풀이)**

①,②에서  변수 x를 참조한다.

JS 엔진은 두개의 변수중

**어떤 변수를 참조 할지 결정한다.**

<br>

이를 **식별자 결정(identifier resolution)[용어]** 이라고 한다.

<br>

**즉!**

JS엔진은 **스코프**를 통해

**식별자를 검색할 때 사용하는 규칙이다.**

<br>

**주의!**

코드 바깥에 선언된 변수 x 와 → 어디서든지 변수 x 참조 가능

foo 함수 내부에 선언된 변수 x는 → 함수 내부에서만 참조 가능

**서로 스코프가 다른 별개의 변수이다.**

<br>

**Why? 왜 스코프가 있을까?**

식별자인 변수 이름의 충돌을 방지하여

**같은 이름의 변수를 사용할 수 있게 한다.**

<br>

**즉!**

스코프 내에선 식별자가 유일해야 하지만

다른 스코프에는 같은 이름 식별자를 사용 가능하다.

<br>

```jsx
function foo() {
  var x = 1;
  // var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용한다.
  // 아래 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다.
  var x = 2;
  console.log(x); // 2
}
foo();
```

<br>

**var 키워드는** 같은 스코프 내에서

같은 이름으로 **중복 선언이 가능**하다.

<br>

```jsx
function bar() {
  let x = 1;
  // let이나 const 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용하지 않는다.
  let x = 2; // SyntaxError: Identifier 'x' has already been declared
}
bar();
```

<br>

하지만 let, const 는 같은 스코프에서 중복선언이 불가능하다.

<br>

## 2. 스코프의 종류

<br>

스코프는

**1 . 전역변수(global)[용어]**

**2 . 지역변수(local)[용어]**

두가지로 구분된다.

<br>

**How? 어떻게 구분 할까?**

**변수는 자신이 선언된 위치에 의해**

**스코프가 결정된다.**

<br>

전역에서 선언되면

전역 스코프를 갖는 전역 변수이고, 

<br>

지역에서 선언되면

지역 스코프를 갖는 지역 변수다.

<br>

### 2.1. 전역과 전역 스코프

<br>


**전역[용어]** 이란 **코드 가장 바깥 영역**이다.

<br>

**전역에 변수를 선언**하면

전역스코프를 갖는

**전역변수(global variable)[용어]** 가 된다.

<br>

**특징!**

전역변수는 **어디서 든지 참조할 수 있다.**

ex) 함수 내부에서도 참조 가능하다.

<br>

위의 예제에서

가장 바깥 x,y 변수가 전역변수이다.

<br>

### 2.2. 지역과 지역 스코프

**지역[용어]** 이란 함수 몸체 내부를 말한다.

<br>

**지역에 변수를 선언**하면

지역스코프를 갖는

**지역변수(local scope)[용어]** 가 된다.

<br>

**주의!**

**지역변수는 자신의 지역스코프와**

**하위 지역 스코프에서만 유효하다.**

<br>

**예제풀이)**

1 . outer 함수 내부의 Z변수는 

- **자신의 지역스코프**
- **하위 지역스코프(inner 함수)**

에서만 **참조 가능하다.**

<br>

**But** 전역에서는 에러 발생한다.

<br>

2  . inner 함수내부 변수 X는

- 자신의 **지역스코프 에서만 참조** 가능하다.

<br>

**But** 이외의 지역에서는 에러발생

<br>

**주의!**

**inner 함수내부의 X변수**와

**전역 변수 X**는

<br>

**서로 다른 스코프에 위치한**

**서로 다른 변수로**

<br>

inner 함수 내부에서 x를 참조하면

지역 변수가 참조 된다.

<br>

**How? 어떤 동작원리로 참조 될까?**

JS엔진이 **스코프체인[용어]** 을 통해 

참조할 변수를 **검색(identifier resolution)[용어]** 한다.

<br>

## 3. 스코프 체인

**스코프는** 함수의 중첩에 의해

**계층적 구조를 갖는다.**

<br>

중첩함수의 

외부함수의 지역스코프를

**상위스코프[용어]** 라한다.

<br>

위의 예제의 계층 그림을 다음과 같다.

이렇게 **스코프가 계층적으로 연결된것**을

**스코프 체인[용어]** 이라고한다.

<br>

**중요!**

**변수를 참조할때 JS엔진은**

**스코프체인을 통해**

<br>

**변수를 참조하는 스코프에서 시작해서**

**상위스코프 방향으로 이동하며**

**선언된 변수를 검색(identifier resolution) 한다.**

<br>

**How? 어떻게 스코프체인을 이용하는지 알아보자.**

<br>

### 3.1. 스코프 체인에 의한 변수 검색

<br>

**위의 예제로 스코프체인 이해하기**

<br>

예제 ④

1 . x 변수를 참조하는 스코프 내에서 **x 변수가 선언되었는지 확인**

<br>

2 . 선언이 **존재하므로 참조후 검색종료**

<br>

예제 ⑤

1 . y 변수를 참조하는 스코프내에 y변수가 **선언되었는지 확인**

<br>

2 . 선언이 존재하지 않으므로 **상위스코프로 이동**(outer 함수)해서 선언되었는지 확인

<br>

3 . 선언이 존재 하지 않으므로 **상위스코프인 전역스코프로 이동후** y변수 선언 확인

<br>

4 . y 변수 선언이 **존재하므로** **참조후 검색 종료**

<br>

예제 ⑥

1 . z변수를 참조하는 스코프 내에 **선언 되었는지 확인**

<br>

2 . 선언이 없으므로 **상위스코프(outer)로 이동후 선언 확인**

<br>

3 . z 변수 **선언이 존재하므로 참조후 검색 종료.**

<br>

**요약!**

**상위스코프에서 선언한 변수는**

**하위스코프에서 자유롭게 참조 가능!**

<br>

**But**

**하위스코프에서 선언된 변수를**

**상위스코프에서 참조 불가능.**

<br>
<br>

### 3.2. 스코프 체인에 의한 함수 검색

<br>

```jsx
// 전역 함수
function foo() {
  console.log('global function foo');
}

function bar() {
  // 중첩 함수
  function foo() {
    console.log('local function foo');
  }

  foo(); // ①
}

bar();
```

<br>

**변수 스코프와 마찬가지로 함수도 같다.**

①에서 호출을 하기위해

식별자 foo를 검색한다.

<br>

**즉!**

스코프는 **변수를 위한 것만이 아닌**

**"식별자를 검색하는 규칙"** 

이라고 표현하는게 적합하다.

<br>
<br>

## 4. 함수 레벨 스코프

<br>

**지역스코프**는 코드블록이 아닌

**함수에 의해서만** 지역스코프가 **생성된다.**

<br>

**C, 자바 등등 VS 자바스크립트**

<br>

C, 자바 언어들은 **모든 코드블록 안에서**

**지역스코프를 만든다.**

**→ 블록 레벨 스코프(block level scope)[용어]**

<br>

자바스크립트 언어에서는 **함수 블록만을**

**지역스코프로 인정한다.**

**→ 함수 레벨 스코프(function level scope)[용어]**

<br>

```jsx
var x = 1;

if (true) {
  // var 키워드로 선언된 변수는 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정한다.
  // 함수 밖에서 var 키워드로 선언된 변수는 코드 블록 내에서 선언되었다 할지라도 모두 전역 변수다.
  // 따라서 x는 전역 변수다. 이미 선언된 전역 변수 x가 있으므로 x 변수는 중복 선언된다.
  // 이는 의도치 않게 변수 값이 변경되는 부작용을 발생시킨다.
  var x = 10;
}

console.log(x); // 10
```

<br>

**예제풀이)**

**함수블록만 지역스코프를 인정**하므로

 if 문안의 **변수 x는 전역변수** 이므로

10의 값이 재할당 되었다.

<br>

```jsx
var i = 10;

// for 문에서 선언한 i는 전역 변수다. 이미 선언된 전역 변수 i가 있으므로 중복 선언된다.
for (var i = 0; i < 5; i++) {
  console.log(i); // 0 1 2 3 4
}

// 의도치 않게 변수의 값이 변경되었다.
console.log(i); // 5
```

<br>

**예제풀이)**

역시 함수 레벨 스코프 이므로 for문의

코드블록의 변수 i는 전역 변수이다.

<br>

**블록 레벨 스코프**는 

**for문에서의 i를 지역변수로 해준다.**

<br>

**주의!**

ES6에서 도입된 let, const 키워드는

블록 레벨 스코프를 지원한다.

<br>
<br>

## 5. 렉시컬 스코프

<br>

```jsx
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // ?
bar(); // ?
```

<br>

**예제풀이)**

bar 함수의 **상위스코프가** 

**무엇인지 결정하는데는 2가지 패턴이 있다.**

<br>

1 . 어디서 함수를 **호출** 했는지

2 . 어디서 함수를 **정의** 했는지

<br>

에따라 **상위 스코프가 달라진다.**

<br>

**첫번째 방식**은 

<br>

**함수가 호출**되는

**시점에 동적으로 상위스코프를 결정**하기 때문에

**동적 스코프(dynamic scope)[용어]** 라고 부른다.

<br>

**단점!**

함수를 정의하는 시점때는

어디서 호출될지 알 수 가 없다.

<br>

**두번째 방식**은

<br>

**함수 정의**가 되는 

**시점에 정적으로 상위 스코프를 결정**하기 때문에

**렉시컬 스코프(lexical scope)[용어]** or **정적 스코프(static scope)[용어]** 라고 부른다.

<br>

→ 자바스크립트를 비롯한 대부분 언어가 렉시컬 스코프 이다.

<br>

위의 예제의

**동적 스코프를 따르면**

<br>

bar 함수의 상위스코프는 

foo 함수의 지역스코프와 전역스코프 이다.

<br>

**렉시컬 스코프를 따르면**

bar 함수의 상위스코프는

전역스코프 이다.

<br>

**정리! 따라서**

**자바스크립트**는 호출에 상관없이

함수가 **정의된 곳에 따라** 스코프가

결정되는 **렉시컬 스코프** 이다.

<br>

따라서

위의 예제는 전역변수 x의 값 1를 두번출력한다.

[Notion](https://www.notion.so/13-4ccc9a6a45ca4573b548716253d83ef3)