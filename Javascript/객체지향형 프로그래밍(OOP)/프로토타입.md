프로토타입
===
## 1. 객체 생성자
객체 생성자는 함수를 통해서 새로운 객체를 만들고 파라미터로 인자 또는 함수들을 구현 할 수 있게 해준다.

```js
function Animal(type, name, sound) {
  this.type = type;
  this.name = name;
  this.sound = sound;
  this.say = function() {
    console.log(this.sound);
  };
}

const dog = new Animal('개', '멍멍이', '멍멍');
const cat = new Animal('고양이', '야옹이', '야옹');

dog.say();
cat.say();
// 멍멍
// 야옹
```

>함수로 객체생성자를 사용할때 이름은 대문자로 쓴다.
또 새로운 객체를 만들때는 `new` 키워드를 써준다.

## 2. 프로토타입

같은 객체 생성자 함수를 사용하는 경우, 특정 함수 또는 값을 재사용 할 수 있는데 이걸 프로토타입이라고 한다.

```js
function Animal(type, name, sound) {
  this.type = type;
  this.name = name;
  this.sound = sound;
}

Animal.prototype.say = function() {
  console.log(this.sound);
};
Animal.prototype.sharedValue = 1;

const dog = new Animal('개', '멍멍이', '멍멍');
const cat = new Animal('고양이', '야옹이', '야옹');

dog.say();
cat.say();

console.log(dog.sharedValue);
console.log(cat.sharedValue);
// 멍멍
// 야옹
// 1 
// 1 
```
> 만약 Animal이라는 객체 생성을 1억개를 하면 각각 say 라는 함수를 가지고 있으므로 엄청난 메모리가 할당이 된다.

> 하지만 프로토타입을 쓰게되면 부모의 say()함수를 써서 굉장히 효율적으로 쓸수 있게된다.

> dog 와 cat이 Animal의 프로토타입으로 속성값이 say함수와 sharedValue의 값이 추가된다.

### 2.1 어떻게 프로토타입으로 dog와 cat이 Animal의 객체를 참조할수 있을까?
> Prototype Link의 핵심인 __proto__는 객체가 생성될 때 조상이었던 함수의 Prototype Object를 참조한다. dog와 cat은 생성될때 Animal의 Prototype Object을 탐색하고 그위에 또 조상이 있으면 계속 탐색 한후 속성이 없으면 undefined을 리턴한다.

> 이렇게 위의 조상을 탐색하는 것을 프로토타입 체인(prototype chain)이라 부르며 프로토타입 기반 언어(prototype-based language)이라고 부른다. 


## 3. 객체 생성자 상속받기

>만약 위의 Dog와 Cat이라는 새로운 객체 생성자를 만들고 다시 Animal의 기능을 재사용 한다고 한다면 call을 쓰면된다.

```js
function Animal(type, name, sound) {
  this.type = type;
  this.name = name;
  this.sound = sound;
}

Animal.prototype.say = function() {
  console.log(this.sound);
};

function Dog(name,sound){
  Animal.call(this, '개', name, sound);
}

Dog.prototype = Animal.prototype;

function Cat(name, sound){
  Animal.call(this, '고양이', name, sound);
}

Cat.prototype = Animal.prototype;

let dog = new Dog('멍멍이', '멍멍');
let cat = new Cat('야옹이', '야옹');

dog.say();
cat.say();
// 멍멍
// 야옹

```
