# 원시값과 객체 비교

- 출처 [모던 자바스크립트 Deep Dive](http://www.yes24.com/Product/Goods/92742567?OzSrank=1)을 보고 정리한 내용입니다.

<br>

자바스크립트의 **데이터 타입**은 총 **7가지**이다.

<br>

7가지도 크게 **2가지 타입**으로 **구분** 될수 있다.

1. **원시타입(primitive type)**
2. **객체타입(object / reference type)**

<br>

**What? 어떤점이 다른 걸까?**

1 . **원시타입**은 **변경 불가능 한값(immutable value)**

**객체 타입**은 **변경 가능한 값(mutable value)**

<br>

2 .  **원시값**을 **변수**에 할당시 **변수**에는 **실제 값이 저장**.

**객체**를 **변수**에 할당시 **변수**에 **참조값 저장**

<br>

3 .  원시값을 갖는 **변수**를 **다른변수에 할당시.**

원본의 **원시값이 복사**되어 전달 → **값에 의한 전달(pass by value)[용어]**

객체를 가리키는 **변수**를 **다른 변수에 할당시**.

원본의 **참조값이 복사** 되어 전달. → **참조에 의한 전달(pass by reference)[용어]**

<br>
<br>

## 1. 원시값

<br>

### 1.1 변경 불가능한 값

<br>

**원시값**은 값이 **변경 불가능한 값**이다.

<br>

**Why? 어째서 변경 불가능할까?**

**변수**는 식별자로서 **메모리 공간의 주소**를 **연결**해 주는 이름의 역활을 한다.

→ **즉!** **변경이 불가능 한것**은 **변수**가 아니라 **값**이다.

<br>

**상수**는 **재할당**이 **금지**된 변수를 말한다.

→ **즉!** **변수**는 재할당 될때 **메모리 주소**가 **바뀌지만**

**상수**는 **재할당 자체가 금지**되어있다.

```jsx
// const 키워드를 사용해 선언한 변수는 재할당이 금지된다. 상수는 재할당이 금지된 변수일 뿐이다.
const o = {};

// const 키워드를 사용해 선언한 변수에 할당한 원시값(상수)은 변경할 수 없다.
// 하지만 const 키워드를 사용해 선언한 변수에 할당한 객체는 변경할 수 있다.
o.a = 1;
console.log(o); // {a: 1}
```

<br>

**때문에!** 

**원시값**은 **읽기 전용 값**으로 **데이터 신뢰성**을 보장한다.

<br>

**원시값**을 할당한 **변수**에 **재할당**을 하면

1. **새로운 메모리 공간 확보**
2. **재할당한 원시값 저장**
3. 변수는 새롭게 **재할당 원시값을 가리킨다**.

→ **메모리 공간의 주소도 바뀐다.**

<br>

**Why? 메모리 공간 주소가 변경된 이유는 무엇일까?**

**원시값**은 **변경 불가능 한 값**이므로

변수의 **새로운 메모리 공간을 확보** 할수 밖에없다.

→ 이러한 특성을 **불변성(immutability)[용어]** 이라고 한다.

<br>

만약 값이 변경된다면 상태 변경을 추적하기 어려울 것이다.

<br>
<br>

### 1.2. 문자열과 불변성

<br>

**원시값을 저장**하려면 먼저 확보해야하는

**메모리 공간의 크기**를 결정 해야한다.

<br>

**데이터 타입별**로 **메모리 공간 크기가 다르다**.

**What? 그렇다면 각 타입별로 크기가 어떻게 될까?**

**문자열 타입**은 **2byte**

**숫자 타입**은 **8byte**

**이외의 원시타입**은 **크기를 명확히 규정하고 있지 않아**

브라우저 제조사 별로 다를수 있다.

<br>

**특징1!**
**문자열의 독특한 특징**이 있다.

문자열은 **1개의 문자마다** **2바이트의 메모리 공간**이 저장된다.

→ 1개면 2바이트, 10개면 20바이트

<br>

**How? 그렇다면 다른 데이터 타입들은 어떨까?**

데이터 타입의 메모리 공간들은

**숫자값**은 1도, 1000000도 동일한 **8바이트만 필요**하다

**각 정해진 메모리 공간**만 사용한다.

```jsx
// 문자열은 0개 이상의 문자들로 이뤄진 집합이다.
var str1 = '';      // 0개의 문자로 이뤄진 문자열(빈 문자열)
var str2 = 'Hello'; // 5개의 문자로 이뤄진 문자열
```

<br>

**특징2!**

문자열은 원시타입으로 변경이 불가능 하다.

```jsx
var str = 'Hello';
str = 'world';
```

<br>

**예제풀이)**

1 . 첫번째 문이 실행되면 **문자열 'Hello'가 생성**

<br>

2 . 식별자 str은 문자열 **'Hello' 가 저장된 메모리 공간**의

첫번째 **메모리 셀 주소를 가리킨다.**

<br>

3 .  두번째 문이 실행되면 기존의 **'Hello'를 수정하는 것이 아니라**

**새로운 문자열 'world'를 생성**

<br>

4 . 식별자는 **새로운 문자열('world') 메모리 주소를 가리킨다.**

<br>
<br>
       
**특징3!**

문자열은 **유사 배열 객체[용어]** 이면서

**배열**과 유사하게 **각 문자에 접근 할수 있다.**

<br>

**What? 유사 배열 객체가 무엇일까?**

마치 배열처럼 **인덱스로 프로퍼티 값에 접근**할 수 있고

**length 프로퍼티**를 갖는 객체를 말한다.

<br>

배열처럼 **인덱스를 통해 각 문자에 접근**할 수 있으며,

**for 문으로 순회**할 수도 있다.

<br>

**주의!**

배열처럼 인덱스를 통해 각 문자에 접근은 가능하지만!!

문자열은 **원시값 이므로 변경 할수 없다.**

<br>

```jsx
var str = 'string';

// 문자열은 유사 배열이므로 배열과 유사하게 인덱스를 사용해 각 문자에 접근할 수 있다.
// 하지만 문자열은 원시값이므로 변경할 수 없다. 이때 에러가 발생하지 않는다.
str[0] = 'S';

console.log(str); // string
```

<br>

### 1.3. 값에 의한 전달

<br>

```jsx
var score = 80;
var copy = score;

console.log(score); // 80
console.log(copy);  // 80

score = 100;

console.log(score); // 100
console.log(copy);  // ?
```

<br>

**예제풀이)**

<br>

1. socre에 80할당
2. copy 변수에 score 변수 할당

→ score 변수의 원시값 80이 복사되어 copy에 전달 된다 **(값에 의한 전달[용어])**

<br>

**주의!**

score 변수와 copy 변수는

숫자값 80을 갖는 점에서 동일하지만.

<br>

score 변수와 copy 변수의 값 80은

**서로 다른 메모리 공간에 저장된 별개의 값이다.**

<br>

3. score 변수에 100 재할당

→ 다른 메모리 공간의 주소에 숫자값 100을 넣음

<br>

**여기서!**

**copy 변수**의 값은 처음부터

**score 변수와 다른 메모리 주소였으므로**

**바뀌지 않는다.**

<br>

**하지만!**

**ECMAScript 사양에서 변수를 통해 메모리를 어떻게 관리 하는지**

**명확하게 정의 되어 있지않다.**

<br>

이때 **두가지 평가 방식**이 가능하다.

1 . **새로운 80을 생성(복사)해서 메모리 주소를 전달하는 방식**. 이 방식은 할당 시점에 두 변수가 기억하는 **메모리 주소가 다르다.**

<br>

2 . **score의 변수값 80의 메모리 주소를 그대로 전달하는 방식**. 이 방식은 할당 시점에 두 변수가 기억하는 **메모리 주소가 같다.**

<br>

**중요한것은**

**두 변수 어느 한쪽에서 재할당을 통해 값을 변경하더라도**

**서로 간섭할수 없다는 것이다.**

<br>
<br>

## 2. 객체

<br>

객체는 프로퍼티의 개수가 정해져 있지 않다.

동적으로 추가하고 삭제 할수 있는, 변경 가능한 타입이다.

<br>

**다른 언어와의 다른 장점**

자바,C++ 같은 **다른 클래스 기반객체 지향 프로그래밍 언어**는

**사전에 정의**된 클래스 기반으로 **객체(인스턴스)** 를 생성한다.

<br>

즉 객체를 생성하기 이전에 **이미 프로퍼티와 메서드가 정해져** 있어

**프로퍼티**를 **삭제**하거나 **추가 할수 없다.**

<br>

**자바스크립트**는

**클래스 없이 객체를 생성** 할 수 있으며

생성 이후 동적으로 **프로퍼티**와 **메서드**를 추가 할 수 있다.

<br>

**단점**

사용하기는 편리하지만

**성능은 떨어지고** **접근에서 비효율 적**이다.

<br>

**보안점**

프로퍼티를 접근하기 위해

**동적 탐색(dynamic lookup)[용어] 대신**

**히든 클래스(hidden class)[용어]를 사용한다.**

→ 성능 어느정도 향상 시킨다.

<br>

### 2.1. 변경 가능한 값

<br>

객체타입의 값, 객체는 **변경 가능한 값(mutable value)** 이다.

```jsx
var person = {
  name: 'Alex'
};
```

<br>

**객체**를 할당한 **변수**가

기억하는 **메모리 공간**를 통해

→ 객체의 **메모리** **공간안**에 **다른 메모리 주소(참조값)** 가 있다.

<br>

**메모리 공간에 접근** 하면

**참조값(reference value)에 접근** 할 수 있다.

<br>

**What? 참조값?**

**참조값[용어]** 은 생성된 객체가 저장된

**메모리 공간의 주소** 그 자체 이다.

<br>

**즉!**

객체를 할당한 **변수**는

이 **참조값**을 **통해** **객체에 접근** 할 수 있다.

<br>

```jsx
// 할당이 이뤄지는 시점에 객체 리터럴이 해석되고, 그 결과 객체가 생성된다.
var person = {
  name: 'Alex'
};

// person 변수에 저장되어 있는 참조값으로 실제 객체에 접근해서 그 객체를 반환한다.
console.log(person); // {name: "Alex"}
```

<br>

**원시값**을 할당한 **변수**의 경우

“변수는 ◯값을 갖는다.” 또는 “**변수의 값**은 ◯이다.”라고 표현한다.

<br>

**하지만** 

**객체**를 할당한 **변수**의 경우

“**변수**는 **객체를 참조**하고 있다” 또는 “**변수는 객체를 가리키고(point) 있다**”

라고 표현한다.

<br>
<br>


**객체** **특징**

**객체**를 할당한 **변수**는

**재할당 없이** 객체를**직접 변경 할 수 있다.**

<br>

**즉,** 재할당 없이 프로퍼티를

동적으로 **추가**, 값을 **갱신**, **삭제** **할 수 있다.**

```jsx
var person = {
  name: 'Alex'
};

// 프로퍼티 값 갱신
person.name = 'Kim';

// 프로퍼티 동적 생성
person.address = 'Seoul';

console.log(person); // {name: "Kim", address: "Seoul"}
```

<br>

**헷갈릴 수 있는 점**

원시값은 재할당으로

값을 새롭게 생성했지만

<br>

**객체**는 직접 수정 할수 있어,

**변수의 참조값**은 **변하지 않는다.**

<br>

**Why? 어째서 객체는 값을 새롭게 생성하지 않고 직접 수정할까?**

객체를 변경할 때마다

이전값을 복사해서 새롭게 생성한다면

<br>

**객체의 크기가 매우 클 수도 있고**

크기가 일정하지 않아 **효율이 너무 나빠진다.**

<br>

**따라서**

메모리 사용의 **효율성과 성능을 위해**

어느정도의 **구조적 단점을 감안한 설계**라고 할 수 있다.

<br>

**구조적 단점에 따른 부작용**

원시값과 다르게

**여러 개의 식별자가 하나의 객체를 공유 할 수 있다.**

<br>
<br>

**객체를 복사하는 2가지 경우**

1 . **얇은 복사(shallow copy)[용어]**

→ 객체 프로퍼티의 값을 **한 단계까지만 복사**하는 것

2. **깊은 복사(deep copy))[용어]**

→ 객체에 **중첩**되어 있는 **객체 까지** **모두 복사** 하는것.

<br>

```jsx
const o = {
  a: {
    b: 2
  },
  f() {}
};

// 얕은 복사
let c = { ...o }; // "35. 스프레드 문법" 참고
console.log(o === c); // false
console.log(o.a === c.a); // true

// 얕은 복사
c = Object.assign({}, o);
console.log(o === c); // false
console.log(o.a === c.a); // true

// JSON.parse와 JSON.stringify를 사용한 깊은 복사
c = JSON.parse(JSON.stringify(o));
console.log(o === c); // false
console.log(o.a === c.a); // false
// 메서드가 사라진다!
console.log(c.f); // undefined

// lodash의 cloneDeep을 사용한 깊은 복사
// "npm install lodash"로 lodash를 설치한 후, Node.js 환경에서 실행
const _ = require('lodash');

c = _.cloneDeep(o);
console.log(o === c); // false
console.log(o.a === c.a); // false
console.log(c.f); // f
```

<br>

이렇게 **두가지 복사**로 **생성된 객체**는

**원본과는 다른 객체이다.**

<br>

**여기서 중요 및 주의!**

만약 **객체안에 중첩**되어 있는 **객체의 경우**

<br>

1 . **얕은 복사**는

객체의 **한 단계는 복사**를 하지만

더 깊은 **중첩된 객체는 참조값을 복사**한다!

<br>

2.  **깊은 복사**는

객체의 중첩되어 있는 객체까지

**모두 복사**해서 원시값 처럼 **완전한 복사본을 만든다.**

<br>
<br>

**참고**

**원시값을 할당한 변수를**

**다른 변수에 할당** 하는 것을 

**깊은 복사** 라고 부르 경우도 있다.

<br>

**객체를 할당한 변수**를

**다른 변수에 할당** 하는 것을

**얕은 복사**라고 부르는 경우도 있다.

<br>
<br>

### 2.2. 참조에 의한 전달

<br>

```jsx
var person = {
  name: 'Alex'
};

// 참조값을 복사(얕은 복사)
var copy = person;
```

<br>

객체를 가리키는 **변수(원본,person)** 를

**다른 변수(사본, copy)에 할당**하면

**원본의 참조값이 복사되어 전달된다.**

<br>

**즉,**

**person의 객체 참조값**을

**새로운 메모리 공간**을 가지고 있는 **copy**에

참조값을 그대로 **가져와 복사**한다.

<br>

두 person과 copy는 **다른 메모리 공간 주소**이지만,

**같은 객체 참조값**을 가지고 있으므로

<br>

어느 한쪽에서 **객체를 변경**하면

**서로 영향을 주고 받는다.**

```jsx
var person = {
  name: 'Alex'
};

// 참조값을 복사(얕은 복사). copy와 person은 동일한 참조값을 갖는다.
var copy = person;

// copy와 person은 동일한 객체를 참조한다.
console.log(copy === person); // true

// copy를 통해 객체를 변경한다.
copy.name = 'Kim';

// person을 통해 객체를 변경한다.
person.address = 'Seoul';

// copy와 person은 동일한 객체를 가리킨다.
// 따라서 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다.
console.log(person); // {name: "Kim", address: "Seoul"}
console.log(copy);   // {name: "Kim", address: "Seoul"}
```

<br>

**결국**

**“값에 의한 전달(원시값)”** 과 **“참조에 의한 전달(객체값)”** 은

식별자가 기억하는 **메모리 공간에 저장**되어 있는

**값을 복사해서 전달**한다는 면에서 **동일하다.**

<br>

즉, **변수**에 **저장**되어 있는 **값**이

**원시값**이냐 **참조값**이냐의 **차이만** 있을 뿐이다.

<br>

**따라서** 자바스크립트에는

**“참조에 의한 전달”** 은 **존재하지 않고**

**“값에 의한 전달”** 만이 **존재**한다고 말할 수 있다.

→ 용어가 정해지지 않아 **'공유에 의한 전달(pass by sharing)[용어]'** 라고 부르기도 한다.


[위의 내용 노션으로 정리.](https://www.notion.so/11-7b627a1310594b7e8d21aebd9c81c6cb)