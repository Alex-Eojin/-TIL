# 데이터 타입

- 출처 [모던 자바스크립트 Deep Dive](http://www.yes24.com/Product/Goods/92742567?OzSrank=1)을 보고 정리한 내용입니다.

<br>

**값의 종류**를 **데이터 타입[용어]** 이라고 한다.

<br>

자바스크립트의 **모든 값** 은 **데이터 타입** 을 갖는다.

<br>

ES6에는 7개의 데이터 타입이 있다.

<br>

그중 크게 2개의 타입으로 분류된다.

- **원시 타입[용어]**
- **객체 타입[용어]**

<br>

**What? 원시타입? 객체타입?**

<br>

**원시타입(primitive type)**

1. 숫자 타입 : 숫자, 정수와 실수 모두 포함한다. 단 모든숫자는 실수로서 존재한다.
2. 문자열 타입 : 문자열
3. 불리언 타입 : 논리적 참(true) / 거짓(false)
4. undefined 타입 : var 키워드에 선언된 변수에 암묵적으로 할당된다.
5. null 타입 : 값이 없음을 의도적으로 명시할때
6. 심벌 타입 : ES6에 새롭게 추가. 유일무이한 객체 프로퍼티를 만들때 사용.

<br>

**객체타입(object/reference type)**

1. 객체, 함수, 배열 등등 → 원시타입을 제외한 나머지

<br>

**Why? 왜 이렇게 다양한 타입이 존재할까?**

타입 별로 **목적, 용도, 메모리 공간 크기,** 읽어 들이는 **해석 방식** 이 다르다.

개발자의 명확한 의도를 가지고 생성해야한다!

<br>

## 1. 숫자 타입

<br>

C 또는 Java는 정수, 실수를 구분해서 다양한 **숫자타입[용어]** 존재한다.

<br>

**But! 자바스크립트에는 숫자타입이 단 하나이다.**

<br>

숫자타입의 값은 **모두** **실수** 로 처리하며 정수만을 표현할 데이터 타입은 없다.

→ **모든 숫자타입은 실수!**

<br>

**정수, 실수, 2진수, 8진수, 16진수 리터럴은** 모두 메모리에 **2진수** 로 **저장** 된다.

→ **참조** 할때도 다른 진수를 위한 데이터 타입이 없어 2진수로 메모리에 할당되고 **10진수로 참조** 해서 **해석** 한다.

```jsx
// 숫자 타입은 모두 실수로 처리된다.
console.log(1 === 1.0); // true
console.log(4 / 2);     // 2
console.log(3 / 2);     // 1.5
```

모든 수는 **'실수'** 로 표현되므로 **정수** 끼리 나누어도 **실수** 가 나올수 있다.

<br>

### 1-1 숫자 타입에는 세가지 특별한 값이 있다.

1. infinity
2. -infinity
3. NaN(not-a-number) → 숫자가 아닌값, 숫자가 아니라는뜻

<br>

**주의사항!**

```jsx
NaN === NaN // false
NaN !== NaN // true
```

NaN은 자신과의 비교가 불가능하다.

**그래서! JS에는 isNaN이라는 함수를 제공한다.**

```jsx
isNaN(NaN);       // 참
isNaN(undefined); // 참
isNaN({});        // 참
isNaN('Alex is handsom');    // 참

isNaN(true);      // 거짓
isNaN(null);      // 거짓
isNaN(37);        // 거짓
isNaN(0);         // 거짓
```

<br>

## 2. 문자열 타입

<br>

**문자열[용어]** 은 **텍스트 데이터** 를 나타내는데 사용한다.

<br>

**How? 어떻게 문자열이란것을 표현할까?**

1. 작은 따음표('');
2. 큰따음표("")
3. 백틱(``)

으로 텍스트를 감싼다.

<br>

```jsx
var handsome = 'Alex';
```

**권장! → 작은 따음표('')**

```jsx
string = '작은따옴표로 감싼 문자열 내의 "큰따옴표"는 문자열로 인식된다.';
string = "큰따옴표로 감싼 문자열 내의 '작은따옴표'는 문자열로 인식된다.";
```

<br>

**Why? 왜 문자열만 따음표로 감쌀까?**

**문자열** 을 **키워드와 식별자** 와 구분하기 위해서 이다.

→ 따음표를 붙이지 않으면 **JS엔진** 은 **식별자 또는 키워드** 로 인식한다.

<br>

**특징!**

C 와 Java와 같은 언어와 다르게

**자바스크립트** 의 문자열은 **원시타입** 이며

**변경 불가능한 값(immutable value)** 이다.

<br>

생성후 변경 할수 없다.

Ex) 배열, 객체는 메소드로 내용값을 변경 가능하다.

But 문자열은 불가능

<br>

## 3. 템플릿 리터럴

<br>

**ES6** 에 추가된 **템플릿 리터럴[용어]** 로 문자열을 더 **편리** 하게 **표기** 할수 있게되었다.

<br>

**When? 언제 처리 될까?**

템플릿 리터럴은 '**런타임'** 에 **일반 문자열** 로 변환된다.

<br>

템플릿 리터럴 → 일반 문자열.

<br>

**How 어떻게 템플릿 리터럴로 표기할까?**

일반 문자열은 따옴표로 표기한다.

템플릿 리터럴은 **백틱(``)** 을 사용한다.

<br>

```jsx
var template = `Alex is handsome`;
console.log(template); // Template literal
```

<br>

**What? 어떤 기능이 템플릿 리터럴에 있을까?**

대표적으로

1. **멀티라인 문자열(multi-line string)[용어]**
2. **표현식 삽입(expression interpolation)[용어]**
3. **태그드 템플릿 (tagged template)[용어]**

<br>

### 3-1 기능1. 멀티라인 문자열

<br>

일반 문자열은 **개행(줄바꿈)[용어]** 가 허용되지 않는다.

Ex)

```jsx
var str = 'Hello
world.';
// SyntaxError: Invalid or unexpected token
```

**그래서!** **일반 문자열**에서 개행등을 위해 `\` 로 시작하는 **이스케이프 시퀀스[용어]** 를 사용한다.

<br>

**이스케이프 시퀀스**

[이스케이프 시퀀스](https://www.notion.so/9034e0c9fff14c1eaeceb6c9d28a4e08)

**비교!** 일반문자열 **VS** 템플릿 리터럴

<br>

1. **일반 문자열**

```jsx
var template = 'Hi\n\tAlex\n\tI'm handsome\nBye.';

console.log(template);
/*
Hi
  Alex
  I'm handsome
Bye.
*/
```

<br>

**2. 템플릿 리터럴**

```jsx
var template = `Hi
  Alex
  I'm handsome
Bye`;

console.log(template);
/*
Hi
  Alex
  I'm handsome
Bye.
*/
```

<br>

### 3-2 기능2. 표현식 삽입

<br>

1 . **일반 문자열**을 변수에 저장해 +를 사용해 연결했다.

Ex)

```jsx
var first = 'Alex';
var last = 'kim';

// ES5: 문자열 연결
console.log('My name is ' + first + ' ' + last + '.'); // My name is Alex kim.
```

<br>

**2. 템플릿 리터럴**

**표현식 삽입(${}) 으로 간단히 수행한다.**

```jsx
var first = 'Alex';
var last = 'kim';

// ES6: 표현식 삽입
console.log(`My name is ${first} ${last}.`); // My name is Alex kim.
```

<br>

**주의1! 표현식의 결과가 문자열이 아니여도 강제로 변환한다.**

```jsx
console.log(`1 + 2 = ${1 + 2}`); // 1 + 2 = 3
```

<br>

**주의2!** 

**템플릿 리터럴(``) 백틱에서가 아닌 일반 문자열에 삽입하면 아무 의미 없이 그대로 문자열이 표현된다.**

```jsx
console.log('1 + 2 = ${1 + 2}'); // 1 + 2 = ${1 + 2}
```

<br>

## 4. 불리언 타입

<br>

논리적 참, 거짓을 나타내는 값는 **true, false** 둘뿐이다.

<br>

조건문에 자주 사용된다.

<br>

불리언에 대해서는 **조건문** 챕터때.

<br>

## 5. undefined

<br>

**var** 키워드로 선언된 변수는 암묵적으로 `undefined` 로 **초기화[용어]** 된다

<br>

**따라서! JS엔진이 변수를 초기화 할때 사용하는 값이다.**

→ **즉!** **참조** 했을때 undefined가 반환되면 선언이후 **값이 할당 된적 없다** 고 알수 있다

<br>

JS엔진이 변수를 초기화 할때 사용하는 **암묵적으로 할당** 하는 값이므로

개발자가 `undefined`를 할당하는 것은 좋지않다.

<br>

**How? 그럼 값이 없음을 표현할때 어떻게 할까?**

**null[용어]** 을 할당하면 된다.

<br>

### 5-1 선언 vs 할당

<br>

**선언[용어]** ⇒ JS에 식별자의 존재만 알린다.

**정의[용어]** ⇒ 변수에 **값을 할당**에 변수를 **실체화** 시킨다.

<br>

But, JS는 선언하면 **암묵적**으로 **정의(undefined)** 가 되어 구분이 애매하므로

JS에서는 

**변수 ⇒ 선언**

**함수 ⇒ 정의**

 한다고 표현한다.

 <br>

## 6. null

<br>

프로그래밍 언어에서의 **null[용어]** 값이 없다는 것을 **의도적으로 명시** 할때 사용한다.

<br>

**null을 할당 동작원리**

1. 변수에 **null 할당** → 더이상 이전 값을 참조 하지 않음을 의미
2. 이전에 할당된 값 **명시적 제거**
3. JS 엔진이 메모리 공간을 **가비지 콜렉션** 을 수행해 지워버린다.

<br>

함수가 유효현 값을 반환 할수 없으면 명시적 `null`  을 반환하기도 한다.

<br>

## 7. symbol

<br>

ES6의 추가된 7번째 타입

<br>

심벌값은 다른 값과 중복 되지 않는 값.

<br>

주로 충돌할 위험이 없는 객체의 프로퍼티 키를 만들기 위해 사용한다.

<br>

## 8. 객체타입

<br>

처음에 **7가지의 데이터 타입** 은 크게 **원시타입** 과 **객체타입** 으로 분류한다고 했다.

<br>

JS는 **객체 기반 언어** 여서 **대부분 모든것** 이 **객체** 이다.

<br>

더 자세한 내용은 다른 챕터에서.

<br>

## 9. 데이터 타입의 필요성

<br>

**Why? 왜 데이터 타입이 필요하고 중요할까?**

<br>

### 9-1 첫번째. 데이터 타입에 의한 메모리 공간의 확보와 참조.

```jsx
var score = 100;
```

이 실행 되면

1. 메모리 공간 확보
2. 메모리 공간에 100을 **'2진수'** 로 저장.
3. 여기서 문제! → 숫자값을 저장할때 **메모리 공간 크기** 를 알아야한다.

<br>

**How? 어떻게 사용할 메모리 공간크기를 알까?**

JS엔진은 **데이터 타입** 에 따라

**정해진 크기의 메모리 공간** 을 **확보** 한다.

<br>

**→ 데이터 타입에 따라 메모리 공간 확보 크기가 달라짐!**

<br>

1. 위의 100을 메모리 공간에 **'2진수'** 로 저장후
2. 숫자 타입이므로 **8바이트** 공간확보 → 데이터 타입마다 공간 크기 다름.
3. 참조 할때 **첫번째 메모리셀** 부터

데이터 타입의 **메모리 공간 만큼** 읽어들인다.

→ 그럴려면 데이터 타입을 **정확히** 알아야 **데이터 값을 훼손** 시키지 않는다.

<br>

### 9-2 두번째. 데이터 타입에 의한 값 해석

<br>

**How? 참조시 2진수로 저장된 값을 어떤 데이터 값으로 해석해야 하나?**

값이 **데이터 타입별** 로 **다르게 해석** 되어 **참조** 된다.

<br>

Ex) 메모리 2진수 저장값 : 0100 001

숫자값 해석 ⇒ 65

문자열 해석 ⇒ 'A'

<br>

**위에 모든 내용 요약!**

- 값을 **저장** 할때 **확보** 할 **'메모리 공간 크기'** 를 **결정** 하기 위해서이다.
- **참조** 시 **한번에** 읽을 **메모리 공간** **크기** 결정!
- 메모리의 **'2진수 를 어떻게 해석'** 할지 결정

<br>

## 10. 동적 타이핑

<br>

### 10-1 동적타입 언어 VS 정적 타입 언어

<br>

1 . **정적타입언어**

<br>

**정적타입 언어[용어]** 는 변수를 선언 할때

데이터 타입을 **사전에 선언** 한다.

→ 명시적 타입 선언

<br>

**정적 타입 언어** 는 변수에 **미리 사전에 선언** 하기 때문에

**선언한 타입** 에 맞는 **값** 만 **할당** 가능하다.

<br>

→ 컴파일 시점에 **타입체크[용어]** 를 하여

 **값이 데이터값과 일치** 한지 보고 에러가 발생하면 **실행을 막는다**. (안전성 높다)

 <br>

**2. 동적타입 언어**

<br>

JS는 변수를 선언만 할뿐 **타입을 선언하지 않는다.** (var, let, const)

<br>

때문에 어떠한 값의 **데이터 타입** 이 와도 **자유롭게 할당** 이 가능하다.

<br>

typeof 연산자로 변수를 연산하면

**변수에 할당된 값** 의 **데이터 타입** 을 반환한다.

<br>

**장점!**

변수에 값이 **할당 시점** 에

타입이 **동적으로 결정** 되고

언제든지 **자유롭게 변경** 가능하다.

<br>

즉! JS는 선언이 아닌 **할당** 에 의해 **타입이 결정(타입추론[용어])** 된다. → 동적 타이핑

**재할당** 으로 언제든지 변수는 **타입이 변할** 수 있다.

<br>

### 10-2 동적타입언어 와 변수

<br>

동적 타입언어는 **단점** 이 있다.

1. 변수는 언제든지 변경 가능하므로 **값을 추적** 하기 어렵다.
2. 타입 또한 변경되어 **직접 변수를 확인** 하기 전까지 **확신** 하기 어렵다.
3.  JS엔진은 **암묵적** 으로 **타입** 이 강제 **변환** 될때도 있어 **오류 발생** 가능성이 높다.

→ **유연성** 은 높지만 **신뢰성** 이 낮다.

<br>

따라서 주의사항이 몇가지 있다.

- 변수는 꼭 필요한 경우에 한해 제한적으로 사용한다.
- 변수의 유효 범위(스코프)는 최대한 좁게 만들어 변수의 부작용을 억제해야 한다.
- 전역 변수는 최대한 사용하지 않도록 한다.
- 변수보다는 상수를 사용해 값의 변경을 억제한다.
- 변수 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍한다.