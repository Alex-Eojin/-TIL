# 표현식과 문

- 출처 [모던 자바스크립트 Deep Dive](http://www.yes24.com/Product/Goods/92742567?OzSrank=1)을 보고 정리한 내용입니다.

## 1. 값

**식[용어]** 이 **평가[용어]** 되어 생성된 결과를 **값[용어]** 이라고 부른다.

<br>

**What? 평가란 무엇일까?**

식을 **해석**해서 **값**을 **생성** / **참조(중요!)** 하는것!

**주의!** 값을 **생성** 하는것 뿐 아니라 **참조**해도 평가라고 한다

<br>

```jsx
10 + 30 // 10 + 20 은 평가되어서 값 30을 생성한다!
//-> 식
```

<br>

변수는 **하나의 값** 을 저장하기 위해 붙인 이름이다.

<br>

```jsx
var sum = 10 + 20;
// '10 + 20' 자체가 할당되기 전에 평가되어 값을 생성한다.
```

<br>

다양한 방법으로 값을 생성한다.

위의 예제처럼 식으로 생성할수있고

또는!  가장간단하게 생성할수도 있다!

<br>

**How? 어떻게 가장 간단하게 값을 생성할까?**

가장 기본적인 방법은 **리터럴[용어]** 을 사용하는 것이다!

<br>

## 2. 리터럴

<br>

리터럴이 뭘까?

**사람이 이해**할 수 있는 **문자** 또는 약속된 **기호** 를 사용하는 표기방식이다!

<br>

**What? 그럼 사람이 이해 할수 있는 문자? 기호는 무엇일까?**

Ex) 문자 → 아라비아 숫자, 알파벳, 한글.... 등등

기호 → '', "", . , [], {}, // ..... 등등

<br>

**When? 언제 리터러를 이용해 값을생성 할까?**

변수는 '소스코드 평가' 시간때 했었다.

리터럴은 **'런타임'** 시간때 값을 평가해 생성한다.

<br>

## 3. 표현식

<br>

표현 값으로서 **평가되어 질수 있는** **문** 을 표현식 이고 한다.

→ 즉! 표현식이 평가 되면 **새로운 값을 생성** 하거나 **기존 값을 참조**한다!

<br>

리터럴은 값으로 **평가** 되어진다!

→ 평가 되어지는 것은 무엇이다? 표현식이다!

<br>

```jsx
var socore = 100;
// 100은 리터럴(100으로 값을 생성해서 평가 되었다.) -> 표현식
```

```jsx
var  score = 50 + 50;
// 50 + 50 은 리터럴 50과 연산자 +로 이뤄져 있다.
// 하지만 평가되어서 100을 생성하므로 표현식이다
```

```jsx
score; // 100
```

`score` 을 참조하면 값이 평가된다.

→ 생성은 안하지만 '참조'도 값으로 평가되므로 표현식이다.

<br>

**즉! 값으로 평가되는 문은 모드 표현식이다!**

→**값 = 표현식**

<br>

다시 돌아가면

표현식은 값으로 평가되어진 것이다.

→ 그렇다면! 표현식과 평가된 값은 **동등**하다고 볼수있다.

이러한 것을 **동치[용어]** 라고한다.

<br>

**그렇다면! 표현식을 값처럼 사용 할수 있다.**

'문법적으로 값이 위치할수 있는 자리에 표현식도 올수 있다!'를 의미한다.

<br>

따라서 숫자 값이 위치해야할 자리에 표현식이 와서

<br>

**표현식**이 **다른 표현식**의 **일부**가 되어 새로운 값을 만들어 낼수 있다!

ex)

```jsx
var x = 1 + 2;
x + 3; // -> 6
```

<br>

## 4. 문

<br>

프로그램을 구성하는 **최소 실행단위** 를 **문[용어]** 이라고 한다.

<br>

문의 집합 → 프로그램

문을 작성, 순서에 맞게 나열 → 프로그래밍

<br>

문은 여러 **토근[용어]** 으로 구성된다.

<br>

What? 토근이 뭔대?

문법적으로 더이상 나눌수 없는 코드의 요소.

<br>

Ex) 

```jsx
var sum = 1 + 2 ; // -> 문
```

여기서 토큰은 각각 하나하나 즉 = var, sum, = , 1, +, 2, ;  이 각각 토큰이다.

<br>

이 모든 것을 합친 것을 **문[용어]** 라고한다.

<br>

**What? 문이 뭘 하는대?**

문은 **실행**이 되어지고 실행되어 어떤일이 일어난다.

→ 즉 문은 컴퓨터에 **명령**을 내리는 **명령문[용어]** 이라고 부른다.

<br>

## 5. 세미콜론과 세미콜론 자동 삽입 기능

<br>

문은 프로그램을 실행시킨다.

또한 실행한뒤 종료를 나타내기 위해 **세미콜론(;)[용어]** 을 사용한다.

<br>

**But 중괄호로 묶인 코드블록 뒤에는 붙이지 않는다.**

<br>

**Why? 왜 안붙이는데 다 붙이라면서?**

문의 종료를 의미하는 **자체 종결성[용어]** 을 갖기 때문이다.

<br>

문뒤에 JS엔진이 자동으로 **예측되는 지점에 세미콜론**을 자동으로 붙여주는

**세미콜론 자동 삽입 기능(ASI, automatic semicolon insertion)** 이 암묵적으로 수행한다.

<br>

→ but 생략 가능하지만 개발자의 **예상과 다른 지점에 붙여 줄수 있어 권장하지 않는다.(쓰지말자)**

<br>

## 6. 표현식인 문과 표현식이 아닌 문

<br>

**표현식 < - > 문** 구별

<br>

**문**에는 두가지가 있다

1. 표현식인 문 (O) 
2. 표현식이 **아닌**문 (X)

<br>

**Why? 왜 표현식과 문을 구별해야할까?**

자바스크립트 엔진에서 코드를 읽고 **실행결과를 예측할때** 도움이 된다.

→ **버그**를 줄이고 **코드 품질**을 높인다.

<br>

**How? 어떻게 구별 할까?**

표현식인 문 → 값으로 **평가**

표현식이 아닌문 → 값으로 **평가** 하지 않는다 (값이 아니다!)

<br>

다시. **평가**란 → 값을 **생성 / 참조** 하는것.

<br>

가장 쉬운 방법인 **변수**에 직접 **할당**하는 것이다.

<br>

Cuz, **표현식인 문 ==  값**

→ 변수에 **할당** 가능!

<br>

표현식이 아닌문은 값이 아니므로 변수에 할당이 안된다.

→ 에러 발생!

<br>

Ex)

```jsx
var x; // 값으로 평가 할수 없다. 왜냐 생성 / 참조가 아니므로
// -> 선언문

x = 100; // 값으로 평가 될수 있다. 리터럴 100으로 값을 생성을 했으므로
// -> 할당문

var foo = x = 100; // 할당문은 표현식인 문이므로 값으로 사용 가능하므로!
console.log(foo); // 100
```

<br>

### 6-1 완료값

<br>

크롬 개발자 도구에서 '표현식이 아닌문' 은 

즉 값이 아니면 **'undefined'** 를 출력한다.

→ 이를 **완료값[용어]** 이라고 한다.