# 리덕스 미들웨어

<br>

API 요청에 대한 상태를 잘관리 해야한다.

<br>

만약 요청이 시작했을때 로딩중,

요청이 성공했을때, 실패했을때 로딩이 끝났음을 명시 해주어야한다.

<br>

이러한 비동기 작업을 관리해야한다면 미들웨어를 사용하면 좋다.

<br>

리덕스, 리액트 리덕스, 리액트 액션 설치

```bash
npm i redux react-redux redux-actions
```

<br>

## 미들웨어란?

<br>

액션을 디스패치 했을때 리듀서에서 처리하기전에 미리 미들웨어를 처리한다.

<br>

미들웨어는 액션과 리듀서 사이의 중간 과정이라고 볼 수 있다.

<br>

액션 → 미들웨어 → 리듀서 → 스토어

<br>

미들웨어가 할 수 있는 작업은

1 . 전달 받은 액션을 단순히 **콘솔에 기록하거나**

2 . 전달 받은 액션 정보를 기반으로 **액션을 아예 취소 하거나**

3 . **다른 종류의 액션을 추가**로 디스패치에 전달 할 수 있다.

<br>

미들웨어는 이미 오픈소스로 많이 만들어져있다.

<br>

미들웨어 함수 구조

```jsx
const middleware = store = next = action => {}
```

<br>

함수안에 함수안에 함수를 반환한다.

<br>

store은 리덕스 스토어 인스턴스

next는 함수형태로 store.dispatch와 비슷한 역활

action은 액션

<br>

**주의!**

next가 store.dispatch와 비슷하다고 했다.

하지만 dispatch(action) 와 next(action)가 다른점이있다.

<br>

next(action)을하면 다음 처리해야할 미들웨어에게 액션을 넘겨준다.

만약없다면! 리듀서에게 액션을 넘겨준다.

```jsx
const loggerMiddleWare = (store) => (next) => (action) => {
  console.group(action && action.type);
  console.log('이전 상태', store.getState());
  console.log('액션', action);
  next(action); // 다음 미들웨어 혹은 리듀서에게 전달
  console.log('다음 상태', store.getState());
  console.groupEnd();
};

export default loggerMiddleWare;
```

<br>

미들웨어 적용하는 방법

```jsx
const store = createStore(rootReducer, applyMiddleware(loggerMiddleWare));
```

<br>

createStore의 두번째 매개변수에 applyMiddleware(미들웨어)함수를 넣어주어야한다.

index.js에서 store을 생성할때 같이 적용하면된다.

<br>

### redux-logger 사용

<br>

위에서 직접 logger 미들웨어를 만들었지만 이미 만들어진 라이브러리가 있다.

redux-looger를 사용하면 더 깔끔하고 잘만들어져 있다.

<br>

사용방법

```bash
npm i redux-logger
```

<br>

```jsx
const store = createStore(rootReducer, applyMiddleware(logger));
```

<br>

## 비동기 작업 처리하는 미들웨어 사용

<br>

**비동기 작업을 처리하는 미들웨어**

- redux-thunk: 비동기 작업을 처리할때 가장 많이 사용하는 미들웨어. 객체가 아니라 함수형태의 액션을 디스패치 할 수 있게 해준다.
- redux-saga: 특정 액션이 디스패치 되었을때 정해진 로직에 따라 다른 액션을 디스패치 시키는 규칙을 작성해 비동기 작업을 처리한다.

<br>

### redux-thunk

<br>

액션 생성 함수에서 일반 액션 객체를 반환하는 것이아닌 

함수를 반환하는것도 가능하게 해준다.

<br>

dispatch가 되었을때 바로 리듀서에서 작업되는 것이아닌

중간 미들웨어를 거치기 때문에 가능하다.

<br>

redux-thunk 코드를 보면 

```jsx
const thunk = ({ dispatch, getState }) => next => action => {
		typeof action === 'function' ? action(dispatch, getState) : next(action)
}
```

<br>

만약 action이 함수인경우 위와 같이 action 함수에 dispatch와 getState가 들어가 호출되어진다.

<br>

액션 함수에 첫번째 파라미터로 dispatch가 들어가고

두번째 파라미터로 getState가 들어간다.

<br>

덕분에 액션 함수는 dispatch, getState함수를 사용할 수 있게된다!

```jsx
const sampleThunk= () => (dispatch,getState) => {
	// 첫번째 파라미터덕분에 새 액션을 디스패치도 가능하다.
	// 두번째 파라미터덕분에 현재 상태 참조가능
}
```

<br>

설치 방법

```bash
npm i redux-thunk
```

<br>

적용방법

```bash
import ReduxThunk from 'redux-thunk';

const store = createStore(rootReducer, applyMiddleware(logger, ReduxThunk));
```

<br>

미들웨어에 적용해주면 된다.!

<br>

예제)

```jsx
export const increaseAsync = () => (dispatch) => {
  setTimeout(() => {
    dispatch(increase());
  }, 1000);
};

export const decreaseAsync = () => (dispatch) => {
  setTimeout(() => {
    dispatch(increase());
  }, 1000);
};
```

<br>

액션함수로 만들어서 dispatch에 액션함수를 넘길경우 redux-thunk 미들웨어에 의해 

dispatch를 파라미터 값으로 받아 올 수 있다.

<br>

따라서 위와 같이 setTimoute함수안에 dispatch를 사용할 수 있게된다.